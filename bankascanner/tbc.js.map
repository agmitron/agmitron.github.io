{"version":3,"file":"tbc.js","sources":["../../../src/tbc/tbc.ts"],"sourcesContent":["import { Importer, Result, Definition } from \"bankascanner/importer\";\nimport { pdf2text } from \"../pdf2text\";\nimport { Failure, Operation, Outcome } from \"bankascanner\";\nimport { Either, left, right } from \"bankascanner/lib\";\n\ntype Parser<Field extends keyof Operation> = (\n  match: string,\n) => Either<string, Operation[Field]>;\n\ntype ParsersMap = {\n  [K in keyof Operation]: Parser<K>;\n};\n\nconst clean = (s: string) =>\n  s\n    .replace(/\\r/g, \"\")\n    .replace(/[\\u2000-\\u200F]/g, \"\")\n    .replace(/[\\u2028\\u2029]/g, \"\\n\")\n    .replace(/\\u00A0/g, \" \")\n    .replace(/, ([\\u10A0-\\u10FF])/g, \",\\n$1\")\n    .replace(/GL\\.23S\\s+\\(/, \"GL.23S\\n(\")\n    .replace(/OSN\\s+(\\d)/, \"OSN\\n$1\")\n    .replace(/\\n\\s+/g, \"\\n\")\n    .replace(/\\s+\\n/g, \"\\n\")\n    .replace(/\\n /g, \"\\n\")\n    .trim();\n\nconst parsers: ParsersMap = {\n  category: (m) => right(clean(m)),\n  comment: (m) => right(clean(m)),\n  currency: (m) => right(m.trim()),\n  value: (m) => {\n    const n = Number(m.replace(/,/g, \"\"));\n    return isNaN(n) ? left(`failed to parse ${m}`) : right(n);\n  },\n  date: (m) => {\n    const [d, mo, y] = m.split(\"/\");\n    const date = new Date(`${y}-${mo}-${d}`);\n    return isNaN(date.getTime()) ? left(`failed to parse ${m}`) : right(date);\n  },\n};\n\nconst rowRegex =\n  /(\\d{2}\\/\\d{2}\\/\\d{4})\\s+([\\s\\S]*?)\\s{2,}([\\s\\S]*?)\\s+([0-9]+\\.[0-9]{2})\\s+([0-9]+\\.[0-9]{2})/g;\n\nconst importer: Importer = async (file: Uint8Array): Promise<Result> => {\n  const text = await pdf2text(new Uint8Array(file));\n\n  const openingMatch = /Opening Balance\\s+([0-9]+\\.[0-9]{2})/.exec(text);\n  if (!openingMatch) {\n    return left(\"failed to parse opening balance\");\n  }\n  let previousBalance = parseFloat(openingMatch[1]);\n\n  const headerIndex = text.indexOf(\"ბალანსი Balance\");\n  if (headerIndex === -1) {\n    return left(\"failed to find table header\");\n  }\n  const content = text.slice(headerIndex + \"ბალანსი Balance\".length);\n\n  const outcomes: Outcome[] = [];\n  let match: RegExpExecArray | null;\n  while ((match = rowRegex.exec(content))) {\n    const [, dateRaw, categoryRaw, commentRaw, amountRaw, balanceRaw] = match;\n\n    const date = parsers.date(dateRaw);\n    const category = parsers.category(categoryRaw);\n    const comment = parsers.comment(commentRaw);\n    const amount = parsers.value(amountRaw);\n    const balance = parseFloat(balanceRaw);\n\n    if (date.isLeft() || category.isLeft() || comment.isLeft() || amount.isLeft()) {\n      const failure: Failure = { message: \"failed to parse row: \" + match[0] };\n      outcomes.push(left(failure));\n      previousBalance = balance;\n      continue;\n    }\n\n    const value = balance >= previousBalance ? amount.value : -amount.value;\n    previousBalance = balance;\n\n    const operation: Operation = {\n      date: date.value,\n      category: category.value,\n      comment: comment.value,\n      value,\n      currency: \"USD\",\n    };\n\n    outcomes.push(right(operation));\n  }\n\n  return right(outcomes);\n};\n\nconst definition: Definition = {\n  name: \"TBC\",\n  version: \"latest\",\n  run: importer,\n};\n\nexport default definition;\n"],"names":["clean","s","parsers","m","right","n","left","d","mo","y","date","rowRegex","importer","file","text","pdf2text","openingMatch","previousBalance","headerIndex","content","outcomes","match","dateRaw","categoryRaw","commentRaw","amountRaw","balanceRaw","category","comment","amount","balance","failure","value","operation","definition"],"mappings":";;AAaA,MAAMA,IAAQ,CAACC,MACbA,EACG,QAAQ,OAAO,EAAE,EACjB,QAAQ,oBAAoB,EAAE,EAC9B,QAAQ,mBAAmB;AAAA,CAAI,EAC/B,QAAQ,WAAW,GAAG,EACtB,QAAQ,wBAAwB;AAAA,GAAO,EACvC,QAAQ,gBAAgB;AAAA,EAAW,EACnC,QAAQ,cAAc;AAAA,GAAS,EAC/B,QAAQ,UAAU;AAAA,CAAI,EACtB,QAAQ,UAAU;AAAA,CAAI,EACtB,QAAQ,QAAQ;AAAA,CAAI,EACpB,KAAA,GAECC,IAAsB;AAAA,EAC1B,UAAU,CAACC,MAAMC,EAAAA,MAAMJ,EAAMG,CAAC,CAAC;AAAA,EAC/B,SAAS,CAACA,MAAMC,EAAAA,MAAMJ,EAAMG,CAAC,CAAC;AAAA,EAC9B,UAAU,CAACA,MAAMC,EAAAA,MAAMD,EAAE,MAAM;AAAA,EAC/B,OAAO,CAACA,MAAM;AACZ,UAAME,IAAI,OAAOF,EAAE,QAAQ,MAAM,EAAE,CAAC;AACpC,WAAO,MAAME,CAAC,IAAIC,OAAK,mBAAmBH,CAAC,EAAE,IAAIC,EAAAA,MAAMC,CAAC;AAAA,EAC1D;AAAA,EACA,MAAM,CAACF,MAAM;AACX,UAAM,CAACI,GAAGC,GAAIC,CAAC,IAAIN,EAAE,MAAM,GAAG,GACxBO,wBAAW,KAAK,GAAGD,CAAC,IAAID,CAAE,IAAID,CAAC,EAAE;AACvC,WAAO,MAAMG,EAAK,QAAA,CAAS,IAAIJ,EAAAA,KAAK,mBAAmBH,CAAC,EAAE,IAAIC,EAAAA,MAAMM,CAAI;AAAA,EAC1E;AACF,GAEMC,IACJ,iGAEIC,IAAqB,OAAOC,MAAsC;AACtE,QAAMC,IAAO,MAAMC,EAAS,IAAI,WAAWF,CAAI,CAAC,GAE1CG,IAAe,uCAAuC,KAAKF,CAAI;AACrE,MAAI,CAACE;AACH,WAAOV,EAAAA,KAAK,iCAAiC;AAE/C,MAAIW,IAAkB,WAAWD,EAAa,CAAC,CAAC;AAEhD,QAAME,IAAcJ,EAAK,QAAQ,iBAAiB;AAClD,MAAII,MAAgB;AAClB,WAAOZ,EAAAA,KAAK,6BAA6B;AAE3C,QAAMa,IAAUL,EAAK,MAAMI,IAAc,EAAwB,GAE3DE,IAAsB,CAAA;AAC5B,MAAIC;AACJ,SAAQA,IAAQV,EAAS,KAAKQ,CAAO,KAAI;AACvC,UAAM,CAAA,EAAGG,GAASC,GAAaC,GAAYC,GAAWC,CAAU,IAAIL,GAE9DX,IAAOR,EAAQ,KAAKoB,CAAO,GAC3BK,IAAWzB,EAAQ,SAASqB,CAAW,GACvCK,IAAU1B,EAAQ,QAAQsB,CAAU,GACpCK,IAAS3B,EAAQ,MAAMuB,CAAS,GAChCK,IAAU,WAAWJ,CAAU;AAErC,QAAIhB,EAAK,YAAYiB,EAAS,OAAA,KAAYC,EAAQ,OAAA,KAAYC,EAAO,UAAU;AAC7E,YAAME,IAAmB,EAAE,SAAS,0BAA0BV,EAAM,CAAC,EAAA;AACrE,MAAAD,EAAS,KAAKd,OAAKyB,CAAO,CAAC,GAC3Bd,IAAkBa;AAClB;AAAA,IACF;AAEA,UAAME,IAAQF,KAAWb,IAAkBY,EAAO,QAAQ,CAACA,EAAO;AAClE,IAAAZ,IAAkBa;AAElB,UAAMG,IAAuB;AAAA,MAC3B,MAAMvB,EAAK;AAAA,MACX,UAAUiB,EAAS;AAAA,MACnB,SAASC,EAAQ;AAAA,MACjB,OAAAI;AAAA,MACA,UAAU;AAAA,IAAA;AAGZ,IAAAZ,EAAS,KAAKhB,QAAM6B,CAAS,CAAC;AAAA,EAChC;AAEA,SAAO7B,EAAAA,MAAMgB,CAAQ;AACvB,GAEMc,IAAyB;AAAA,EAC7B,MAAM;AAAA,EACN,SAAS;AAAA,EACT,KAAKtB;AACP;"}